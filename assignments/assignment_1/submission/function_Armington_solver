function Armington_solver(A::Array{Float64,1}, L::Array{Float64,1}, tau::Array{Float64,2}, sigma::Float64)
    # ----- Error Checking -----
    N = length(A)
    @assert length(L) == N "A and L must be of equal length."
    @assert all(A .>= 0) "All elements of A must be nonnegative."
    @assert all(L .>= 0) "All elements of L must be nonnegative."
    @assert size(tau, 1) == N && size(tau, 2) == N "tau must be a square matrix with dimension equal to length of A and L."
    @assert sigma > 0 "sigma must be a strictly positive scalar."
    
    # ----- Setup for Fixed-Point Iteration -----
    # We solve for wages w (defined up to a multiplicative constant).
    # Under Armington, the equilibrium conditions imply that:
    #   w_i^σ = (A_i^(1-σ)/L_i) * Σ_j [ w_j L_j * tau[i,j]^(1-σ) / P_j^(1-σ) ],
    # where the CES price index in destination j is defined as
    #   P_j^(1-σ) = Σ_k [ (tau[k,j] * w_k/A_k)^(1-σ) ].
    #
    # We use a fixed-point iteration: given wages, compute all price indices, update wages, and then normalize.
    
    # Initialize wages (relative wages; normalization is arbitrary)
    w = ones(N)
    tol = 1e-8
    max_iter = 10000
    
    for iter in 1:max_iter
        # Compute CES price indices P for each destination j
        P = zeros(N)
        for j in 1:N
            sum_val = 0.0
            for k in 1:N
                # We assume A[k]>0; if A[k]==0, we simply skip that term.
                if A[k] > 0
                    sum_val += (tau[k,j])^(1 - sigma) * (w[k] / A[k])^(1 - sigma)
                end
            end
            # Recover the price index: P_j = (sum_val)^(1/(1-sigma))
            # Note: When sigma>1, 1/(1-sigma) is negative.
            P[j] = sum_val^(1 / (1 - sigma))
        end
        
        # Update wages using the equilibrium condition.
        w_new = zeros(N)
        for i in 1:N
            sum_term = 0.0
            for j in 1:N
                # Accumulate over destinations j.
                # Each term: w[j]*L[j] * tau[i,j]^(1-sigma) / P[j]^(1-sigma)
                sum_term += w[j] * L[j] * (tau[i,j])^(1 - sigma) / (P[j])^(1 - sigma)
            end
            # The fixed-point condition implies:
            #   w_i = [ (A_i^(1-σ) / L_i) * sum_term ]^(1/σ)
            # (We assume L[i] > 0.)
            w_new[i] = ( (A[i]^(1 - sigma) / L[i]) * sum_term )^(1 / sigma)
        end
        
        # Normalize wages (for example, set the wage of country 1 to 1)
        norm_factor = w_new[1]
        w_new .= w_new ./ norm_factor
        
        # Check convergence
        if maximum(abs.(w_new .- w)) < tol
            w = w_new
            break
        end
        
        w = w_new
    end
    
    return w
end